<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UniqueSeeker's Algae Map</title>

  <style>
    :root{
      --bg:#0b1220;
      --accent:#4fb3ff;
      --text:#e8f0ff;
      --glass:rgba(255,255,255,0.10);
      --glass2:rgba(255,255,255,0.16);
      --border:rgba(255,255,255,0.18);
      --shadow:0 14px 40px rgba(0,0,0,0.45);
      --card:rgba(255,255,255,0.98);
    }

    body{ margin:0; overflow:hidden; background:var(--bg); font-family:system-ui, Arial; }

    /* Keep UI above WebGL + constellation canvas */
    #topbar, #hint, #overlay, #popup { position:fixed; z-index:9999; }

    #topbar{
      top:15px; left:15px;
      display:flex; gap:10px; align-items:center;
      color:var(--text);
      background:var(--glass);
      border:1px solid var(--border);
      padding:10px 12px;
      border-radius:14px;
      backdrop-filter: blur(8px);
      max-width: calc(100vw - 30px);
      flex-wrap: wrap;
    }
    #topbar a{
      color:var(--text);
      text-decoration:none;
      border-bottom:1px dashed rgba(255,255,255,0.45);
    }
    button{
      cursor:pointer;
      border:none;
      border-radius:12px;
      padding:8px 10px;
      font-weight:800;
      background:var(--glass2);
      color:var(--text);
    }
    button:hover{ background:rgba(255,255,255,0.25); }

    #hint{
      left:15px; bottom:15px;
      color:var(--text);
      background:var(--glass);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(8px);
      max-width:80vw;
    }

    /* Constellation drawing layer (above WebGL, below UI) */
    #constellationCanvas{
      position:fixed;
      inset:0;
      z-index:5000;
      background:transparent;
      pointer-events:auto;
      touch-action:none; /* helps on mobile */
    }

    #overlay{
      inset:0;
      background:rgba(0,0,0,0.45);
      display:none;
    }
    #overlay.show{ display:block; }

    #popup{
      top:15px; right:15px;
      width:340px;
      max-height:78vh;
      overflow:auto;
      background:var(--card);
      border-radius:16px;
      padding:14px;
      display:none;
      box-shadow:var(--shadow);
      border:3px solid color-mix(in srgb, var(--accent) 65%, transparent);
    }
    #popup.show{ display:block; }

    #popupHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding-bottom:10px;
      border-bottom:2px solid color-mix(in srgb, var(--accent) 35%, transparent);
      margin-bottom:10px;
    }
    #popupTitle{
      margin:0;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:18px;
      line-height:1.2;
    }
    #dot{
      width:14px; height:14px;
      border-radius:999px;
      background:var(--accent);
      box-shadow:0 0 0 3px color-mix(in srgb, var(--accent) 25%, transparent);
      flex:0 0 auto;
    }
    #closeBtn{
      background: color-mix(in srgb, var(--accent) 18%, rgba(0,0,0,0.06));
      color:#111;
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
    }

    .sectionTitle{
      margin:10px 0 6px;
      font-size:12px;
      letter-spacing:.35px;
      text-transform:uppercase;
      color:#444;
    }
    ul{ margin:6px 0 0 18px; }

    @media (max-width:768px){
      #popup{
        left:10px; right:10px;
        top:auto; bottom:10px;
        width:auto;
        max-height:60vh;
        border-radius:18px;
      }
      #topbar{ right:15px; }
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="topbar">
    <b>UniqueSeeker's Algae Map</b>
    <span style="opacity:.8">•</span>
    <a href="../" title="Back to main site">Back</a>
    <button id="resetBtn">Reset View</button>
    <button id="constBtn" title="Tap stars to draw. Double tap to clear.">
      Constellation: ON
    </button>
  </div>

  <div id="hint">Drag to rotate • Scroll/pinch to zoom • Tap a district • Tap stars to connect (auto-fade)</div>

  <canvas id="constellationCanvas"></canvas>

  <div id="overlay"></div>

  <div id="popup" role="dialog" aria-modal="true">
    <div id="popupHeader">
      <h3 id="popupTitle"><span id="dot"></span><span id="titleText">District</span></h3>
      <button id="closeBtn">Close</button>
    </div>

    <div class="sectionTitle">Common algae (4–5)</div>
    <div id="algaeList"></div>

    <div class="sectionTitle">Commonly seen in (real locations)</div>
    <div id="habitatList"></div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    /* =========================
       DATA (edit anytime)
    ========================= */
    const algaeByDistrict = {
      "Thiruvananthapuram": ["Spirogyra","Oedogonium","Cladophora","Nostoc","Scenedesmus"],
      "Kollam": ["Cladophora","Spirogyra","Scenedesmus","Pediastrum","Nostoc"],
      "Pathanamthitta": ["Cosmarium","Staurastrum","Spirogyra","Nostoc","Scenedesmus"],
      "Alappuzha": ["Nostoc","Pediastrum","Scenedesmus","Spirogyra","Cladophora"],
      "Kottayam": ["Spirogyra","Cosmarium","Scenedesmus","Pediastrum","Nostoc"],
      "Idukki": ["Cosmarium","Staurastrum","Spirogyra","Cladophora","Nostoc"],
      "Ernakulam": ["Cladophora","Scenedesmus","Spirogyra","Pediastrum","Nostoc"],
      "Thrissur": ["Spirogyra","Oedogonium","Scenedesmus","Pediastrum","Nostoc"],
      "Palakkad": ["Oedogonium","Spirogyra","Scenedesmus","Nostoc","Pediastrum"],
      "Malappuram": ["Spirogyra","Scenedesmus","Cladophora","Nostoc","Pediastrum"],
      "Kozhikode": ["Cosmarium","Cladophora","Scenedesmus","Spirogyra","Nostoc"],
      "Wayanad": ["Cosmarium","Staurastrum","Spirogyra","Nostoc","Pediastrum"],
      "Kannur": ["Cladophora","Scenedesmus","Spirogyra","Nostoc","Pediastrum"],
      "Kasaragod": ["Spirogyra","Cladophora","Scenedesmus","Nostoc","Pediastrum"]
    };

    const habitatsByDistrict = {
      "Thiruvananthapuram": ["Neyyar River","Karamana River","Vamanapuram River"],
      "Kollam": ["Ashtamudi Lake","Kallada River"],
      "Pathanamthitta": ["Pamba River (Aranmula belt)","Manimala River (Kallooppara belt)","Achankovil River (Konni belt)"],
      "Alappuzha": ["Pamba River","Manimala River","Achankovil River","Vembanad / Punnamada Lake (backwaters)"],
      "Kottayam": ["Meenachil River","Vembanad Lake (Kumarakom)"],
      "Idukki": ["Periyar River (upper stretches)","Reservoir margins (Idukki region)"],
      "Ernakulam": ["Periyar River (Aluva belt)","Kochi backwater region","Vembanad lake margins"],
      "Thrissur": ["Chalakudy River","Karuvannur River (Kole wetlands)","Bharathapuzha (Nila)"],
      "Palakkad": ["Malampuzha Reservoir / Dam","Malampuzha River","Bharathapuzha (Nila)"],
      "Malappuram": ["Chaliyar River","Kadalundi River","Bharathapuzha (Nila)","Tirur River"],
      "Kozhikode": ["Kallayi River","Chaliyar River"],
      "Wayanad": ["Kabini River system","Panamaram River","Mananthavady River"],
      "Kannur": ["Valapattanam River","Anjarakandy River","Kuppam River"],
      "Kasaragod": ["Chandragiri (Payaswini) River","Kariangode River"]
    };

    /* =========================
       POPUP UI
    ========================= */
    const overlay = document.getElementById("overlay");
    const popup = document.getElementById("popup");
    const titleText = document.getElementById("titleText");
    const algaeList = document.getElementById("algaeList");
    const habitatList = document.getElementById("habitatList");
    const closeBtn = document.getElementById("closeBtn");

    function setAccent(hex){ document.documentElement.style.setProperty("--accent", hex); }

    function openPopup(district, hex){
      setAccent(hex);
      titleText.textContent = district;

      const algae = (algaeByDistrict[district] || ["No data"]).slice(0,5);
      algaeList.innerHTML = `<ul>${algae.map(a=>`<li>${a}</li>`).join("")}</ul>`;

      const hab = habitatsByDistrict[district] || ["Ponds","Canals","River edges"];
      habitatList.innerHTML = `<ul>${hab.map(h=>`<li>${h}</li>`).join("")}</ul>`;

      overlay.classList.add("show");
      popup.classList.add("show");
    }

    function closePopup(){
      overlay.classList.remove("show");
      popup.classList.remove("show");
    }

    popup.addEventListener("pointerdown", (e)=> e.stopPropagation(), {passive:false});
    popup.addEventListener("click", (e)=> e.stopPropagation());
    closeBtn.addEventListener("click", closePopup);
    overlay.addEventListener("pointerdown", closePopup);

    /* =========================
       THREE.JS SETUP
    ========================= */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 9000);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 90;
    controls.maxDistance = 1600;

    scene.add(new THREE.AmbientLight(0xffffff, 0.82));
    const sun = new THREE.DirectionalLight(0xffffff, 0.95);
    sun.position.set(220, 520, 180);
    scene.add(sun);

    /* =========================
       NIGHT SKY 360 STARS
       + subtle rotation + twinkle
    ========================= */
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 2600;
    const starPositions = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
      const radius = 3000;
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);

      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);

      starPositions[i * 3 + 0] = x;
      starPositions[i * 3 + 1] = y;
      starPositions[i * 3 + 2] = z;
    }

    starsGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));

    const starsMaterial = new THREE.PointsMaterial({
      color: 0xfff3c4,
      size: 7,
      sizeAttenuation: true,
      transparent: true,
      opacity: 1,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const starField = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starField);

    /* =========================
       MAP BUILD
    ========================= */
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const clickable = [];

    const mapGroup = new THREE.Group();
    scene.add(mapGroup);

    function projectLonLat(lon, lat){
      const scale = 20;
      return new THREE.Vector2(lon*scale, lat*scale);
    }

    const PALETTE = [
      "#ff6b6b","#ffd93d","#6bcb77","#4d96ff","#9d4edd","#ff9f1c","#00bbf9",
      "#f15bb5","#00f5d4","#b8f2e6","#f7b267","#7bdff2","#c77dff","#80ed99"
    ];
    function paletteColor(i){ return new THREE.Color(PALETTE[i % PALETTE.length]); }

    let selectedMesh = null;
    function setSelected(mesh){
      if (selectedMesh && selectedMesh.material){
        selectedMesh.material.emissive = new THREE.Color(0x000000);
        selectedMesh.material.emissiveIntensity = 0;
        selectedMesh.position.y -= 1.2;
      }
      selectedMesh = mesh;
      if (selectedMesh && selectedMesh.material){
        const glow = selectedMesh.material.color.clone().lerp(new THREE.Color(0xffffff), 0.35);
        selectedMesh.material.emissive = glow;
        selectedMesh.material.emissiveIntensity = 0.85;
        selectedMesh.position.y += 1.2;
      }
    }

    const geo = await fetch("./kerala_districts.geojson").then(r => r.json());

    const features = [...geo.features].sort((a,b)=>{
      const A = (a.properties?.shapeName || "").toLowerCase();
      const B = (b.properties?.shapeName || "").toLowerCase();
      return A.localeCompare(B);
    });

    for (let idx=0; idx<features.length; idx++){
      const f = features[idx];
      const name = f.properties?.shapeName || "Unknown";
      const geom = f.geometry;

      const districtColor = paletteColor(idx);
      const hex = "#" + districtColor.getHexString();

      const polys = (geom.type === "Polygon") ? [geom.coordinates]
                  : (geom.type === "MultiPolygon") ? geom.coordinates
                  : [];

      for (const poly of polys){
        const outer = poly[0];
        if (!outer || outer.length < 3) continue;

        const pts = outer.map(([lon,lat]) => projectLonLat(lon,lat));
        const shape = new THREE.Shape(pts);

        const extrudeGeo = new THREE.ExtrudeGeometry(shape, { depth: 10, bevelEnabled: false });

        const mat = new THREE.MeshStandardMaterial({
          color: districtColor,
          roughness: 0.92,
          metalness: 0.00,
          flatShading: true,
          polygonOffset: true,
          polygonOffsetFactor: 2,
          polygonOffsetUnits: 2,
          side: THREE.FrontSide,
          emissive: new THREE.Color(0x000000),
          emissiveIntensity: 0
        });

        const mesh = new THREE.Mesh(extrudeGeo, mat);
        mesh.rotation.x = -Math.PI/2;
        mesh.userData = { name, hex };
        mesh.position.y += 0.01;

        mapGroup.add(mesh);
        clickable.push(mesh);

        const edges = new THREE.EdgesGeometry(extrudeGeo, 25);
        const line = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity:0.30 })
        );
        line.rotation.x = -Math.PI/2;
        line.position.copy(mesh.position);
        mapGroup.add(line);
      }
    }

    const bbox = new THREE.Box3().setFromObject(mapGroup);
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    mapGroup.position.sub(center);

    function fitCamera(){
      const box = new THREE.Box3().setFromObject(mapGroup);
      const size = new THREE.Vector3();
      box.getSize(size);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let dist = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      dist *= (window.innerWidth < 768) ? 1.6 : 1.25;

      camera.position.set(0, dist * 0.85, dist);
      controls.target.set(0, 0, 0);
      controls.update();
    }
    fitCamera();

    /* =========================
       CONSTELLATION DRAWING
       - Tap stars to connect
       - Max 6 stars
       - Lines fade out automatically
       - Double tap clears instantly
    ========================= */
    const constCanvas = document.getElementById("constellationCanvas");
    const ctx = constCanvas.getContext("2d");

    function resizeConstCanvas(){
      constCanvas.width = Math.floor(innerWidth * devicePixelRatio);
      constCanvas.height = Math.floor(innerHeight * devicePixelRatio);
      constCanvas.style.width = innerWidth + "px";
      constCanvas.style.height = innerHeight + "px";
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    resizeConstCanvas();

    const starPosAttr = starsGeometry.getAttribute("position");
    const tmpV3 = new THREE.Vector3();

    // Each point: { idx, t }
    let constellation = [];
    const MAX_CONST_POINTS = 6;
    const FADE_MS = 12000; // 12s fade
    let constellationEnabled = true;

    const constBtn = document.getElementById("constBtn");
    constBtn.addEventListener("click", () => {
      constellationEnabled = !constellationEnabled;
      constBtn.textContent = constellationEnabled ? "Constellation: ON" : "Constellation: OFF";
      if (!constellationEnabled){
        constellation = [];
        ctx.clearRect(0,0, innerWidth, innerHeight);
      }
    });

    function starScreenPos(i){
      tmpV3.set(
        starPosAttr.getX(i) + starField.position.x,
        starPosAttr.getY(i) + starField.position.y,
        starPosAttr.getZ(i) + starField.position.z
      );
      tmpV3.project(camera);
      return {
        x: (tmpV3.x * 0.5 + 0.5) * innerWidth,
        y: (-tmpV3.y * 0.5 + 0.5) * innerHeight,
        visible: tmpV3.z >= -1 && tmpV3.z <= 1
      };
    }

    function pickNearestStar(screenX, screenY){
      const isMobile = window.innerWidth < 768;
      const MAX_DIST = isMobile ? 34 : 28;
      const MAX_D2 = MAX_DIST * MAX_DIST;

      let best = -1;
      let bestD2 = Infinity;
      let secondD2 = Infinity;

      for (let i = 0; i < starCount; i++){
        const p = starScreenPos(i);
        if (!p.visible) continue;

        const dx = p.x - screenX;
        const dy = p.y - screenY;
        const d2 = dx*dx + dy*dy;

        if (d2 < bestD2){
          secondD2 = bestD2;
          bestD2 = d2;
          best = i;
        } else if (d2 < secondD2){
          secondD2 = d2;
        }
      }

      // "Clearly closest" rule (reduces wrong picks when stars are dense)
      // If second nearest is too close, reject.
      const CLEAR_RATIO = 0.72;
      const clearEnough = (bestD2 < secondD2 * CLEAR_RATIO);

      if (bestD2 <= MAX_D2 && (secondD2 === Infinity || clearEnough)){
        return best;
      }
      return -1;
    }

    function addConstellationPoint(idx){
      const last = constellation[constellation.length - 1];
      if (last && last.idx === idx) return;
      if (constellation.length >= MAX_CONST_POINTS) return;
      constellation.push({ idx, t: performance.now() });
    }

    function pruneFaded(now){
      constellation = constellation.filter(p => (now - p.t) < FADE_MS);
    }

    function alphaForPoint(p, now){
      const age = now - p.t;
      const a = 1 - (age / FADE_MS);
      return Math.max(0, Math.min(1, a));
    }

    function drawConstellation(now){
      ctx.clearRect(0,0, innerWidth, innerHeight);
      if (!constellationEnabled) return;

      pruneFaded(now);
      if (constellation.length === 0) return;

      // Lines
      ctx.save();
      ctx.lineWidth = 2.0;
      ctx.strokeStyle = "rgba(255,255,255,1)";
      ctx.shadowColor = "rgba(255,255,255,0.85)";
      ctx.shadowBlur = 12;

      ctx.beginPath();
      let started = false;

      for (let k=0; k<constellation.length; k++){
        const pt = constellation[k];
        const a = alphaForPoint(pt, now);
        const p = starScreenPos(pt.idx);
        if (!p.visible) continue;

        // fade affects drawing: if point is nearly gone, skip it
        if (a < 0.03) continue;

        if (!started){
          ctx.moveTo(p.x, p.y);
          started = true;
        } else {
          ctx.lineTo(p.x, p.y);
        }
      }

      // Apply overall fade using average alpha (simple + looks smooth)
      const avgA = constellation.reduce((s,pt)=>s+alphaForPoint(pt,now),0) / constellation.length;
      ctx.globalAlpha = Math.max(0, Math.min(1, avgA));
      ctx.stroke();
      ctx.restore();

      // Points
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.shadowColor = "rgba(255,255,255,0.9)";
      ctx.shadowBlur = 16;

      for (const pt of constellation){
        const a = alphaForPoint(pt, now);
        const p = starScreenPos(pt.idx);
        if (!p.visible || a < 0.03) continue;

        ctx.globalAlpha = a;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    let lastTapTime = 0;
    function onConstellationPointerDown(e){
      if (!constellationEnabled) return;

      // If popup is open, don't draw
      if (popup.classList.contains("show")) return;

      const now = Date.now();
      const doubleTap = (now - lastTapTime) < 320;
      lastTapTime = now;

      if (doubleTap){
        constellation = [];
        return;
      }

      const x = e.clientX;
      const y = e.clientY;

      const picked = pickNearestStar(x, y);
      if (picked !== -1){
        addConstellationPoint(picked);

        // Stop district click when a star is selected
        e.preventDefault();
        e.stopPropagation();
      }
    }
    constCanvas.addEventListener("pointerdown", onConstellationPointerDown, { passive:false });

    /* =========================
       DISTRICT INTERACTION
    ========================= */
    function onDistrictPointerDown(e){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(clickable, true);

      if (hits.length){
        const obj = hits[0].object;
        setSelected(obj);
        openPopup(obj.userData.name, obj.userData.hex);
      }
    }
    window.addEventListener("pointerdown", onDistrictPointerDown, { passive:true });

    document.getElementById("resetBtn").addEventListener("click", () => {
      closePopup();
      if (selectedMesh) setSelected(null);
      constellation = [];
      fitCamera();
    });

    /* =========================
       LOOP + RESIZE
    ========================= */
    const clock = new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      controls.update();

      // Keep stars surrounding camera (true 360 sky)
      starField.position.copy(camera.position);

      // Slow star rotation (makes sky feel alive)
      starField.rotation.y += 0.00035;
      starField.rotation.x += 0.00008;

      // Subtle twinkle: gentle opacity pulse (not annoying)
      const t = clock.getElapsedTime();
      starsMaterial.opacity = 0.92 + 0.08 * (0.5 + 0.5 * Math.sin(t * 1.15));

      renderer.render(scene, camera);

      // Draw constellation overlay (fading)
      drawConstellation(performance.now());
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      fitCamera();
      resizeConstCanvas();
    });
  </script>
</body>
</html>
