<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UniqueSeeker's Algae Map</title>

  <style>
    :root{
      --bg:#0b1220;
      --accent:#4fb3ff;
      --text:#e8f0ff;
      --glass:rgba(255,255,255,0.10);
      --glass2:rgba(255,255,255,0.16);
      --border:rgba(255,255,255,0.18);
      --shadow:0 14px 40px rgba(0,0,0,0.45);
      --card:rgba(255,255,255,0.98);
    }
    body{ margin:0; overflow:hidden; background:var(--bg); font-family:system-ui, Arial; }

    /* UI always above canvas */
    #topbar, #hint, #overlay, #popup { position:fixed; z-index:9999; }

    #topbar{
      top:15px; left:15px;
      display:flex; gap:10px; align-items:center;
      color:var(--text);
      background:var(--glass);
      border:1px solid var(--border);
      padding:10px 12px;
      border-radius:14px;
      backdrop-filter: blur(8px);
      max-width: calc(100vw - 30px);
      flex-wrap: wrap;
    }
    #topbar a{
      color:var(--text);
      text-decoration:none;
      border-bottom:1px dashed rgba(255,255,255,0.45);
    }
    button{
      cursor:pointer;
      border:none;
      border-radius:12px;
      padding:8px 10px;
      font-weight:800;
      background:var(--glass2);
      color:var(--text);
    }
    button:hover{ background:rgba(255,255,255,0.25); }

    #hint{
      left:15px; bottom:15px;
      color:var(--text);
      background:var(--glass);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(8px);
      max-width:80vw;
    }

    #overlay{
      inset:0;
      background:rgba(0,0,0,0.45);
      display:none;
    }
    #overlay.show{ display:block; }

    #popup{
      top:15px; right:15px;
      width:340px;
      max-height:78vh;
      overflow:auto;
      background:var(--card);
      border-radius:16px;
      padding:14px;
      display:none;
      box-shadow:var(--shadow);
      border:3px solid color-mix(in srgb, var(--accent) 65%, transparent);
    }
    #popup.show{ display:block; }

    #popupHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding-bottom:10px;
      border-bottom:2px solid color-mix(in srgb, var(--accent) 35%, transparent);
      margin-bottom:10px;
    }
    #popupTitle{
      margin:0;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:18px;
      line-height:1.2;
    }
    #dot{
      width:14px; height:14px;
      border-radius:999px;
      background:var(--accent);
      box-shadow:0 0 0 3px color-mix(in srgb, var(--accent) 25%, transparent);
      flex:0 0 auto;
    }
    #closeBtn{
      background: color-mix(in srgb, var(--accent) 18%, rgba(0,0,0,0.06));
      color:#111;
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
    }

    .sectionTitle{
      margin:10px 0 6px;
      font-size:12px;
      letter-spacing:.35px;
      text-transform:uppercase;
      color:#444;
    }
    ul{ margin:6px 0 0 18px; }

    @media (max-width:768px){
      #popup{
        left:10px; right:10px;
        top:auto; bottom:10px;
        width:auto;
        max-height:60vh;
        border-radius:18px;
      }
      #topbar{ right:15px; }
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="topbar">
    <b>UniqueSeeker's Algae Map</b>
    <span style="opacity:.8">•</span>
    <a href="../" title="Back to main site">Back</a>
    <button id="resetBtn">Reset View</button>
  </div>

  <div id="hint">Drag to rotate • Scroll/pinch to zoom • Tap a district</div>

  <div id="overlay"></div>

  <div id="popup" role="dialog" aria-modal="true">
    <div id="popupHeader">
      <h3 id="popupTitle"><span id="dot"></span><span id="titleText">District</span></h3>
      <button id="closeBtn">Close</button>
    </div>

    <div class="sectionTitle">Common algae (4–5)</div>
    <div id="algaeList"></div>

    <div class="sectionTitle">Commonly seen in (real locations)</div>
    <div id="habitatList"></div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    /* =========================
       DATA (edit anytime)
    ========================= */
    const algaeByDistrict = {
      "Thiruvananthapuram": ["Spirogyra","Oedogonium","Cladophora","Nostoc","Scenedesmus"],
      "Kollam": ["Cladophora","Spirogyra","Scenedesmus","Pediastrum","Nostoc"],
      "Pathanamthitta": ["Cosmarium","Staurastrum","Spirogyra","Nostoc","Scenedesmus"],
      "Alappuzha": ["Nostoc","Pediastrum","Scenedesmus","Spirogyra","Cladophora"],
      "Kottayam": ["Spirogyra","Cosmarium","Scenedesmus","Pediastrum","Nostoc"],
      "Idukki": ["Cosmarium","Staurastrum","Spirogyra","Cladophora","Nostoc"],
      "Ernakulam": ["Cladophora","Scenedesmus","Spirogyra","Pediastrum","Nostoc"],
      "Thrissur": ["Spirogyra","Oedogonium","Scenedesmus","Pediastrum","Nostoc"],
      "Palakkad": ["Oedogonium","Spirogyra","Scenedesmus","Nostoc","Pediastrum"],
      "Malappuram": ["Spirogyra","Scenedesmus","Cladophora","Nostoc","Pediastrum"],
      "Kozhikode": ["Cosmarium","Cladophora","Scenedesmus","Spirogyra","Nostoc"],
      "Wayanad": ["Cosmarium","Staurastrum","Spirogyra","Nostoc","Pediastrum"],
      "Kannur": ["Cladophora","Scenedesmus","Spirogyra","Nostoc","Pediastrum"],
      "Kasaragod": ["Spirogyra","Cladophora","Scenedesmus","Nostoc","Pediastrum"]
    };

    const habitatsByDistrict = {
      "Thiruvananthapuram": ["Neyyar River","Karamana River","Vamanapuram River"],
      "Kollam": ["Ashtamudi Lake","Kallada River"],
      "Pathanamthitta": ["Pamba River (Aranmula belt)","Manimala River (Kallooppara belt)","Achankovil River (Konni belt)"],
      "Alappuzha": ["Pamba River","Manimala River","Achankovil River","Vembanad / Punnamada Lake (backwaters)"],
      "Kottayam": ["Meenachil River","Vembanad Lake (Kumarakom)"],
      "Idukki": ["Periyar River (upper stretches)","Reservoir margins (Idukki region)"],
      "Ernakulam": ["Periyar River (Aluva belt)","Kochi backwater region","Vembanad lake margins"],
      "Thrissur": ["Chalakudy River","Karuvannur River (Kole wetlands)","Bharathapuzha (Nila)"],
      "Palakkad": ["Malampuzha Reservoir / Dam","Malampuzha River","Bharathapuzha (Nila)"],
      "Malappuram": ["Chaliyar River","Kadalundi River","Bharathapuzha (Nila)","Tirur River"],
      "Kozhikode": ["Kallayi River","Chaliyar River"],
      "Wayanad": ["Kabini River system","Panamaram River","Mananthavady River"],
      "Kannur": ["Valapattanam River","Anjarakandy River","Kuppam River"],
      "Kasaragod": ["Chandragiri (Payaswini) River","Kariangode River"]
    };

    /* =========================
       POPUP UI
    ========================= */
    const overlay = document.getElementById("overlay");
    const popup = document.getElementById("popup");
    const titleText = document.getElementById("titleText");
    const algaeList = document.getElementById("algaeList");
    const habitatList = document.getElementById("habitatList");
    const closeBtn = document.getElementById("closeBtn");

    function setAccent(hex){ document.documentElement.style.setProperty("--accent", hex); }

    function openPopup(district, hex){
      setAccent(hex);
      titleText.textContent = district;

      const algae = (algaeByDistrict[district] || ["Spirogyra","Nostoc","Cladophora","Scenedesmus"]).slice(0,5);
      algaeList.innerHTML = `<ul>${algae.map(a=>`<li>${a}</li>`).join("")}</ul>`;

      const hab = habitatsByDistrict[district] || ["Ponds","Canals","River edges"];
      habitatList.innerHTML = `<ul>${hab.map(h=>`<li>${h}</li>`).join("")}</ul>`;

      overlay.classList.add("show");
      popup.classList.add("show");
    }

    function closePopup(){
      overlay.classList.remove("show");
      popup.classList.remove("show");
    }

    // prevent accidental close on mobile
    popup.addEventListener("pointerdown", (e)=> e.stopPropagation(), {passive:false});
    popup.addEventListener("click", (e)=> e.stopPropagation());
    closeBtn.addEventListener("click", closePopup);
    overlay.addEventListener("pointerdown", closePopup);

    /* =========================
       THREE.JS SETUP
    ========================= */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 9000);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 90;
    controls.maxDistance = 1600;

    scene.add(new THREE.AmbientLight(0xffffff, 0.82));
    const sun = new THREE.DirectionalLight(0xffffff, 0.95);
    sun.position.set(220, 520, 180);
    scene.add(sun);

    /* =========================
       NIGHT SKY 360 STARS
       + subtle rotation + twinkle
    ========================= */
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 2600;
    const starPositions = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
      const radius = 3000;
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);

      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);

      starPositions[i * 3 + 0] = x;
      starPositions[i * 3 + 1] = y;
      starPositions[i * 3 + 2] = z;
    }

    starsGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));

    const starsMaterial = new THREE.PointsMaterial({
      color: 0xfff3c4,
      size: 7,
      sizeAttenuation: true,
      transparent: true,
      opacity: 1,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const starField = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starField);
/* =========================
   MINI ZODIAC CONSTELLATIONS (MORE + DIFFERENT SHAPES)
   - small clusters
   - glowing star nodes
   - dotted lines
   - spread in many places
   - rotates with starField
========================= */

const constellationLayer = new THREE.Group();
starField.add(constellationLayer); // rotates with sky

// Glow sprite (gold)
function makeGlowSprite() {
  const c = document.createElement("canvas");
  c.width = 128; c.height = 128;
  const ctx = c.getContext("2d");
  const g = ctx.createRadialGradient(64,64,2, 64,64,60);
  g.addColorStop(0.00, "rgba(255,200,90,1)");
  g.addColorStop(0.25, "rgba(255,200,90,0.60)");
  g.addColorStop(1.00, "rgba(255,200,90,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(64,64,60,0,Math.PI*2);
  ctx.fill();
  return new THREE.CanvasTexture(c);
}
const glowTex = makeGlowSprite();

/** Convert small local (x,y) to point on sky sphere near a direction */
function toSphere(x, y, theta0, phi0, scale, radius) {
  const theta = theta0 + x * scale;
  const phi   = phi0   + y * scale;

  return new THREE.Vector3(
    radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.sin(phi) * Math.sin(theta),
    radius * Math.cos(phi)
  );
}

/**
 * Create a mini constellation:
 * points: array of [x,y,w] (w controls star size)
 * edges: array of [a,b] connections
 */
function addMiniConstellation({
  points,
  edges,
  theta,
  phi,
  scale = 0.07,
  radius = 3000,
  dotOpacity = 0.95,
  lineOpacity = 0.22,
  dotSizeBase = 8
}) {
  // 3D points
  const pts3 = points.map(([x,y,w]) => ({
    p: toSphere(x,y, theta,phi, scale, radius),
    w
  }));

  // Dots (sprites)
  for (const {p,w} of pts3) {
    const spr = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex,
      transparent:true,
      opacity: dotOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    }));
    const s = dotSizeBase + (w * 10);
    spr.scale.set(s, s, 1);
    spr.position.copy(p);
    constellationLayer.add(spr);
  }

  // Dotted lines (LineDashedMaterial)
  const linePts = [];
  for (const [a,b] of edges){
    linePts.push(pts3[a].p.x, pts3[a].p.y, pts3[a].p.z);
    linePts.push(pts3[b].p.x, pts3[b].p.y, pts3[b].p.z);
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute("position", new THREE.Float32BufferAttribute(linePts, 3));

  const dashed = new THREE.LineDashedMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: lineOpacity,
    dashSize: 8,
    gapSize: 10,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const lines = new THREE.LineSegments(g, dashed);
  lines.computeLineDistances();
  constellationLayer.add(lines);

  // Soft glow copy (fainter)
  const glow = new THREE.LineDashedMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: lineOpacity * 0.45,
    dashSize: 6,
    gapSize: 14,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const glowLines = new THREE.LineSegments(g, glow);
  glowLines.computeLineDistances();
  constellationLayer.add(glowLines);
}

/* -------------------------
   SHAPE TEMPLATES (zodiac-like)
   Each template: points + edges
------------------------- */

// 1) Small chain (Aries-ish)
const SH_CHAIN = {
  points: [
    [-1.2, 0.1, 0.9],
    [-0.4, 0.2, 0.3],
    [ 0.3, 0.0, 0.6],
    [ 1.1,-0.4, 0.2]
  ],
  edges: [[0,1],[1,2],[2,3]]
};

// 2) Long bent chain (Taurus-ish)
const SH_BENT = {
  points: [
    [-1.4, 0.0, 1.0],
    [-0.6, 0.3, 0.4],
    [ 0.1, 0.1, 0.7],
    [ 0.8, 0.2, 0.3],
    [ 1.3,-0.2, 0.8]
  ],
  edges: [[0,1],[1,2],[2,3],[3,4]]
};

// 3) Loop (Gemini-ish)
const SH_LOOP = {
  points: [
    [-1.0, 0.4, 0.7],
    [-0.2, 0.6, 0.3],
    [ 0.6, 0.4, 0.6],
    [ 0.7,-0.2, 0.4],
    [ 0.0,-0.5, 0.9],
    [-0.8,-0.1, 0.3]
  ],
  edges: [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0]]
};

// 4) V shape with tail (Cancer-ish)
const SH_VTAIL = {
  points: [
    [-1.0, 0.3, 0.6],
    [-0.2, 0.1, 0.4],
    [ 0.6, 0.4, 0.9],
    [ 0.2,-0.3, 0.3],
    [-0.4,-0.6, 0.8]
  ],
  edges: [[0,1],[1,2],[1,3],[3,4]]
};

// 5) Zigzag (Leo-ish)
const SH_ZIGZAG = {
  points: [
    [-1.3, 0.1, 0.6],
    [-0.7, 0.5, 0.3],
    [-0.1, 0.0, 0.8],
    [ 0.5, 0.4, 0.4],
    [ 1.2,-0.1, 0.7]
  ],
  edges: [[0,1],[1,2],[2,3],[3,4]]
};

// 6) Triangle-ish but open (Virgo-ish) — not a closed triangle
const SH_OPENTRI = {
  points: [
    [-1.0, 0.0, 0.7],
    [-0.1, 0.6, 0.4],
    [ 0.9, 0.0, 0.9],
    [ 0.1,-0.6, 0.5]
  ],
  edges: [[0,1],[1,2],[2,3]] // open shape
};

// 7) Curved chain (Scorpio-ish)
const SH_CURVE = {
  points: [
    [-1.1, 0.2, 0.8],
    [-0.6, 0.4, 0.3],
    [-0.1, 0.2, 0.6],
    [ 0.4,-0.1, 0.4],
    [ 0.9,-0.4, 0.9],
    [ 1.2,-0.7, 0.5]
  ],
  edges: [[0,1],[1,2],[2,3],[3,4],[4,5]]
};

// 8) Short “boxy” (Libra-ish)
const SH_BOX = {
  points: [
    [-0.8, 0.3, 0.7],
    [ 0.0, 0.5, 0.4],
    [ 0.8, 0.3, 0.8],
    [ 0.5,-0.3, 0.4],
    [-0.3,-0.4, 0.9]
  ],
  edges: [[0,1],[1,2],[2,3],[3,4]]
};

/* -------------------------
   PLACE MANY CONSTELLATIONS
   theta: 0..2π
   phi:   0..π (keep ~0.7..2.2)
------------------------- */
addMiniConstellation({ ...SH_CHAIN,    theta: 0.7, phi: 1.0, scale: 0.065 });
addMiniConstellation({ ...SH_BENT,     theta: 1.6, phi: 0.9, scale: 0.070 });
addMiniConstellation({ ...SH_LOOP,     theta: 2.6, phi: 1.2, scale: 0.075 });
addMiniConstellation({ ...SH_VTAIL,    theta: 3.4, phi: 1.0, scale: 0.070 });
addMiniConstellation({ ...SH_ZIGZAG,   theta: 4.3, phi: 1.15, scale: 0.070 });
addMiniConstellation({ ...SH_OPENTRI,  theta: 5.1, phi: 0.95, scale: 0.065 });
addMiniConstellation({ ...SH_CURVE,    theta: 5.7, phi: 1.25, scale: 0.070 });
addMiniConstellation({ ...SH_BOX,      theta: 0.2, phi: 1.35, scale: 0.070 });

// Optional: slight overall constellation visibility tuning
// constellationLayer.children.forEach(obj => { if(obj.material) obj.material.opacity *= 0.95; });
    /* =========================
       MAP BUILD
    ========================= */
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const clickable = [];

    const mapGroup = new THREE.Group();
    scene.add(mapGroup);

    function projectLonLat(lon, lat){
      const scale = 20;
      return new THREE.Vector2(lon*scale, lat*scale);
    }

    // palette ensures obvious different colors (prevents “same color looks merged”)
    const PALETTE = [
      "#ff6b6b","#ffd93d","#6bcb77","#4d96ff","#9d4edd","#ff9f1c","#00bbf9",
      "#f15bb5","#00f5d4","#b8f2e6","#f7b267","#7bdff2","#c77dff","#80ed99",
      "#ff4d6d","#34d399","#60a5fa","#f59e0b","#a78bfa","#22c55e"
    ];
    function paletteColor(i){ return new THREE.Color(PALETTE[i % PALETTE.length]); }

    let selectedMesh = null;
    function setSelected(mesh){
      if (selectedMesh && selectedMesh.material){
        selectedMesh.material.emissive = new THREE.Color(0x000000);
        selectedMesh.material.emissiveIntensity = 0;
        selectedMesh.position.y -= 1.2;
      }
      selectedMesh = mesh;
      if (selectedMesh && selectedMesh.material){
        const glow = selectedMesh.material.color.clone().lerp(new THREE.Color(0xffffff), 0.35);
        selectedMesh.material.emissive = glow;
        selectedMesh.material.emissiveIntensity = 0.85;
        selectedMesh.position.y += 1.2;
      }
    }

    const geo = await fetch("./kerala_districts.geojson").then(r => r.json());

    // sort to keep stable coloring order
    const features = [...geo.features].sort((a,b)=>{
      const A = (a.properties?.shapeName || "").toLowerCase();
      const B = (b.properties?.shapeName || "").toLowerCase();
      return A.localeCompare(B);
    });

    for (let idx=0; idx<features.length; idx++){
      const f = features[idx];
      const name = f.properties?.shapeName || "Unknown";
      const geom = f.geometry;

      const districtColor = paletteColor(idx);
      const hex = "#" + districtColor.getHexString();

      const polygons = (geom.type === "Polygon") ? [geom.coordinates]
                     : (geom.type === "MultiPolygon") ? geom.coordinates
                     : [];

      for (const poly of polygons){
        const outer = poly[0];
        if (!outer || outer.length < 3) continue;

        const pts = outer.map(([lon,lat]) => projectLonLat(lon,lat));
        const shape = new THREE.Shape(pts);

        const extrudeGeo = new THREE.ExtrudeGeometry(shape, {
          depth: 10,
          bevelEnabled: false
        });

        const mat = new THREE.MeshStandardMaterial({
          color: districtColor,
          roughness: 0.92,
          metalness: 0.00,
          flatShading: true,
          polygonOffset: true,
          polygonOffsetFactor: 2,
          polygonOffsetUnits: 2,
          side: THREE.FrontSide,
          emissive: new THREE.Color(0x000000),
          emissiveIntensity: 0
        });

        const mesh = new THREE.Mesh(extrudeGeo, mat);
        mesh.rotation.x = -Math.PI/2;
        mesh.userData = { name, hex };
        mesh.position.y += 0.01;

        mapGroup.add(mesh);
        clickable.push(mesh);

        // district border
        const edges = new THREE.EdgesGeometry(extrudeGeo, 25);
        const line = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity:0.30 })
        );
        line.rotation.x = -Math.PI/2;
        line.position.copy(mesh.position);
        mapGroup.add(line);
      }
    }

    // center map
    const bbox = new THREE.Box3().setFromObject(mapGroup);
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    mapGroup.position.sub(center);

    function fitCamera(){
      const box = new THREE.Box3().setFromObject(mapGroup);
      const size = new THREE.Vector3();
      box.getSize(size);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let dist = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      dist *= (window.innerWidth < 768) ? 1.6 : 1.25;

      camera.position.set(0, dist * 0.85, dist);
      controls.target.set(0, 0, 0);
      controls.update();
    }
    fitCamera();

    /* =========================
       DISTRICT CLICK
    ========================= */
    function onPointerDown(e){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(clickable, true);

      if (hits.length){
        const obj = hits[0].object;
        setSelected(obj);
        openPopup(obj.userData.name, obj.userData.hex);
      }
    }
    window.addEventListener("pointerdown", onPointerDown, { passive:true });

    document.getElementById("resetBtn").addEventListener("click", () => {
      closePopup();
      if (selectedMesh) setSelected(null);
      fitCamera();
    });

    /* =========================
       LOOP + RESIZE
    ========================= */
    const clock = new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      controls.update();

      // keep stars around camera (true 360 sky)
      starField.position.copy(camera.position);

      // slow sky motion
      starField.rotation.y += 0.00035;
      starField.rotation.x += 0.00008;

      // subtle twinkle
      const t = clock.getElapsedTime();
      starsMaterial.opacity = 0.92 + 0.08 * (0.5 + 0.5 * Math.sin(t * 1.15));

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      fitCamera();
    });
  </script>
</body>
</html>


